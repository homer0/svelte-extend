<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/services/extender.js | svelte-extend</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Create new Svelte components by extending existing ones"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="svelte-extend"><meta property="twitter:description" content="Create new Svelte components by extending existing ones"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/svelte-extend"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/rollup.js~SvelteExtendRollupPlugin.html">SvelteExtendRollupPlugin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-svelteExtendWebpackLoader">svelteExtendWebpackLoader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RollupFilter">RollupFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SvelteExtendRollupPluginOptions">SvelteExtendRollupPluginOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Provider">Provider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ProviderRegisterMethod">ProviderRegisterMethod</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SFCTag">SFCTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Class</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://yarnpkg.com/en/package/jimple">Jimple</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#app">app</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/app/index.js~SvelteExtend.html">SvelteExtend</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#services">services</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/extender.js~Extender.html">Extender</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/jsMerger.js~JSMerger.html">JSMerger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/sfcData.js~SFCData.html">SFCData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/sfcParser.js~SFCParser.html">SFCParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-extender">extender</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-jsMerger">jsMerger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-sfcData">sfcData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-sfcParser">sfcParser</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/services/extender.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const path = require(&apos;path&apos;);
const { provider } = require(&apos;jimple&apos;);
/**
 * This is the class that merges single file components (SFCs).
 */
class Extender {
  /**
   * @param {JSMerger}       jsMerger To merge the JS scripts and remove duplicated declarations.
   * @param {Class&lt;SFCData&gt;} sfcData  To create a &quot;final&quot; SFC with the merged information.
   */
  constructor(jsMerger, sfcData) {
    /**
     * A local reference for the `jsMerger` service.
     * @type {JSMerger}
     * @access protected
     * @ignore
     */
    this._jsMerger = jsMerger;
    /**
     * The class used to create the objects with the SFC merged information.
     * @type {Class&lt;SFCData&gt;}
     * @access protected
     * @ignore
     */
    this._sfcData = sfcData;
    /**
     * A dictionary of regular expression the class uses.
     * @type {Object}
     * @property {RegExp} htmlSrc A expression the class will use to find `src` attributes on
     *                            HTML code in order to update relative paths when merging
     *                            two SFCs.
     * @property {RegExp} cssUrl  A expression the class will use to find `url()` properties on
     *                            CSS code in order to update relative paths when merging
     *                            two SFCs.
     * @property {RegExp} jsPaths A expression the class will use to find `import` statements on
     *                            JS code in order to update relative paths when merging two SFCs.
     * @access protected
     * @ignore
     */
    this._expressions = {
      htmlSrc: /\s+(?:src=&quot;(\.[^&quot;]+)&quot;|src=&apos;(\.[^&apos;]+)&apos;)/ig,
      cssUrl: /url\s*\(\s*(?:[&apos;&quot;])?(\.[^&quot;&apos;]+)(?:[&apos;&quot;])?\)/ig,
      jsPaths: /(?: |^)(?:(?:from|import)\s+(?:[&quot;&apos;](\.[^&quot;&apos;]+)[&quot;&apos;])|require\s*\(\s*[&quot;&apos;](\.[^&quot;&apos;]+)[&quot;&apos;]\s*\))/igm,
    };
    /**
     * A list of private attributes used by the application and that should be removed from
     * tags.
     * @type {Array&lt;String&gt;}
     * @access protected
     * @ignore
     */
    this._privateAttributes = [&apos;extend&apos;];
  }
  /**
   * Takes an SFC data object, check if it extends from another and then does a recursive merge
   * in order to generate a final SFC data object. It&apos;s recursive in case an SFC extends from an
   * SFC that then extends from another...
   * @param {SFCData} sfc          The SFC information.
   * @param {Number}  [maxDepth=0] How many components can be extended. For example, if a file
   *                               extends from one that extends from another and the parameter
   *                               is set to `1`, the parsing will fail.
   * @return {SFCData}
   * @throws {Error} If the &quot;extend chain&quot; goes beyond the `maxDepth` limit.
   */
  generate(sfc, maxDepth = 0) {
    return this._generate(sfc, maxDepth, 1);
  }
  /**
   * The method that actually generates the &quot;final SFC&quot;.
   * @param {SFCData} sfc          The SFC information.
   * @param {Number}  maxDepth     How many components can be extended. For example, if a file
   *                               extends from one that extends from another and the parameter
   *                               is set to `1`, the parsing will fail.
   * @param {Number}  currentDepth The level of depth in which a file is currently being extended.
   * @return {SFCData}
   * @throws {Error} If the &quot;extend chain&quot; goes beyond the `maxDepth` limit.
   * @access protected
   * @ignore
   */
  _generate(sfc, maxDepth, currentDepth) {
    let result;
    if (sfc.hasBaseFileData) {
      const newCurrentDepth = currentDepth + 1;
      if (maxDepth &amp;&amp; newCurrentDepth &gt; maxDepth) {
        throw new Error(
          `The file &apos;${sfc.filepath}&apos; can&apos;t extend from another file, the max depth ` +
          `limit is set to ${maxDepth}`
        );
      }

      const base = this._generate(sfc.baseFileData, maxDepth, newCurrentDepth);
      result = this._extend(base, sfc);
    } else {
      result = sfc;
    }

    return result;
  }
  /**
   * Generates a single SFC data object by merging a base SFC and one that extends it.
   * @param {SFCData} base   The data of the base SFC.
   * @param {SFCData} target The data of the SFC that extends the base.
   * @return {SFCData}
   * @access protected
   * @ignore
   */
  _extend(base, target) {
    const relative = path.relative(target.directory, base.directory);
    const absolute = path.join(target.directory, relative);
    const directory = path.relative(target.directory, absolute);

    const sfc = this._sfcData.new(target.filepath);
    sfc.addMarkup(this._extendMarkup(base, target, directory));
    const moduleScript = this._extendModuleScript(base, target, directory);
    if (moduleScript.content) {
      sfc.addScript(moduleScript.content, moduleScript.attributes);
    }
    const script = this._extendScript(base, target, directory);
    if (script.content) {
      sfc.addScript(script.content, script.attributes);
    }
    const style = this._extendStyle(base, target, directory);
    if (style.content) {
      sfc.addStyle(style.content, style.attributes);
    }

    return sfc;
  }
  /**
   * Generates the markup of the merge of two SFCs. If the extended SFC doesn&apos;t have the `html`
   * attribute on its `&lt;extend /&gt;` tag, the returned markup won&apos;t contain the one from the base
   * SFC.
   * @param {SFCData} base      The data of the base SFC.
   * @param {SFCData} target    The data of the SFC that extends the base.
   * @param {String}  directory The relative directory path between the SFC that extends and the
   *                            base one; this is used to update the relative paths on the code.
   * @return {String}
   * @access protected
   * @ignore
   */
  _extendMarkup(base, target, directory) {
    let result;
    const htmlPosition = this._getMergePosition(target.extendTagAttributes.html);
    if (htmlPosition === null) {
      result = target.markup;
    } else {
      const baseMarkup = this._updateMarkupPaths(base.markup, directory);
      if (htmlPosition === &apos;after&apos;) {
        result = `${baseMarkup}\n${target.markup}`;
      } else {
        result = `${target.markup}\n${baseMarkup}`;
      }
    }

    return this._cleanTextBlock(result);
  }
  /**
   * Generates an style {@link SFCTag} of the merge of two SFCs. If the extended SFC doesn&apos;t
   * have any styling, it will use the one from the base; but if there&apos;s a style tag, it will use
   * that instead; and if the extended style tag uses the `extend` attribute, then the content of
   * both tags will be merged.
   * @param {SFCData} base      The data of the base SFC.
   * @param {SFCData} target    The data of the SFC that extends the base.
   * @param {String}  directory The relative directory path between the SFC that extends and the
   *                            base one; this is used to update the relative paths on the code.
   * @return {SFCTag}
   * @access protected
   * @ignore
   */
  _extendStyle(base, target, directory) {
    const baseStyle = base.style;
    const targetStyle = target.style;
    let attributes;
    let content;
    if (target.hasStyles) {
      const stylePosition = this._getMergePosition(targetStyle.attributes.extend);
      if (stylePosition === null) {
        ({ attributes, content } = targetStyle);
      } else {
        attributes = Object.assign({}, baseStyle.attributes, targetStyle.attributes);
        const newBaseStyle = this._updateCSSPaths(baseStyle.content, directory);
        if (stylePosition === &apos;after&apos;) {
          content = `${newBaseStyle}\n${targetStyle.content}`;
        } else {
          content = `${targetStyle.content}\n${newBaseStyle}`;
        }
      }
    } else {
      ({ attributes } = baseStyle);
      content = this._updateCSSPaths(baseStyle.content, directory);
    }


    return {
      attributes: this._cleanAttributes(attributes),
      content: this._cleanTextBlock(content),
    };
  }
  /**
   * Generates an script {@link SFCTag} of the merge of two SFCs. If the extended SFC doesn&apos;t
   * have any scripts, it will use the one from the base; but if there&apos;s a script tag, it will use
   * that instead; and if the extended script tag uses the `extend` attribute, then the content of
   * both tags will be merged.
   * @param {SFCData} base      The data of the base SFC.
   * @param {SFCData} target    The data of the SFC that extends the base.
   * @param {String}  directory The relative directory path between the SFC that extends and the
   *                            base one; this is used to update the relative paths on the code.
   * @return {SFCTag}
   * @access protected
   * @ignore
   */
  _extendScript(base, target, directory) {
    return this._extendJSBlock(
      base.script,
      target.script,
      target.hasScripts,
      directory
    );
  }
  /**
   * Generates a module script {@link SFCTag} (the ones with the `context=&quot;module&quot;` attribute) of
   * the merge of two SFCs. If the extended SFC doesn&apos;t have any scripts, it will use the one from
   * the base; but if there&apos;s a script tag, it will use that instead; and if the extended script
   * tag uses the `extend` attribute, then the content of both tags will be merged.
   * @param {SFCData} base      The data of the base SFC.
   * @param {SFCData} target    The data of the SFC that extends the base.
   * @param {String}  directory The relative directory path between the SFC that extends and the
   *                            base one; this is used to update the relative paths on the code.
   * @return {SFCTag}
   * @access protected
   * @ignore
   */
  _extendModuleScript(base, target, directory) {
    const mScript = this._extendJSBlock(
      base.moduleScript,
      target.moduleScript,
      target.hasModuleScripts,
      directory
    );
    mScript.attributes.context = &apos;module&apos;;
    return mScript;
  }
  /**
   * This is a utility method used to merge script {@link SFCTag}s. It&apos;s used by both
   * {@link Extender#_extendScript} and {@link Extender#_extendModuleScript}.
   * If the extended SFC doesn&apos;t have any scripts, it will use the one from the base; but if
   * there&apos;s a script tag, it will use that instead; and if the extended script tag uses the
   * `extend` attribute, then the content of both tags will be merged.
   * @param {SFCTag}  baseJS       The tag that represents all the scripts from the base SFC.
   * @param {SFCTag}  targetJS     The tag that represents all the scripts from the extended SFC.
   * @param {Boolean} targetHasJS  Whether or not the extended SFC has any scripts.
   * @param {String}  directory    The relative directory path between the SFC that extends and
   *                               the base one; this is used to update the relative paths on
   *                               the code.
   * @return {SFCTag}
   * @access protected
   * @ignore
   */
  _extendJSBlock(baseJS, targetJS, targetHasJS, directory) {
    let attributes;
    let content;
    if (targetHasJS) {
      if (targetJS.attributes.extend) {
        if (baseJS.content) {
          content = this._jsMerger.mergeCode(
            this._updateJSPaths(baseJS.content, directory),
            targetJS.content
          );
        } else {
          ({ content } = targetJS);
        }

        attributes = Object.assign({}, baseJS.attributes, targetJS.attributes);
      } else {
        ({ attributes, content } = targetJS);
      }
    } else {
      ({ attributes } = baseJS);
      content = this._updateJSPaths(baseJS.content, directory);
    }

    return {
      attributes: this._cleanAttributes(attributes),
      content: this._cleanTextBlock(content),
    };
  }
  /**
   * Updates relative paths on a block of JS code to be relative for a give directory. This is
   * used when a block of JS code is going to be added on a extended SFC.
   * @param {String} js        The code to update.
   * @param {String} directory The relative path to the directory in which the extended SFC is
   *                           located.
   * @return {String}
   * @access protected
   * @ignore
   */
  _updateJSPaths(js, directory) {
    return this._updateCodePaths(
      js,
      this._expressions.jsPaths,
      directory
    );
  }
  /**
   * Updates relative paths on a block of HTML code to be relative for a give directory. This is
   * used when a block of HTML code is going to be added on a extended SFC.
   * @param {String} markup    The code to update.
   * @param {String} directory The relative path to the directory in which the extended SFC is
   *                           located.
   * @return {String}
   * @access protected
   * @ignore
   */
  _updateMarkupPaths(markup, directory) {
    return this._updateCSSPaths(
      this._updateCodePaths(markup, this._expressions.htmlSrc, directory),
      directory
    );
  }
  /**
   * Updates relative paths on a block of CSS code to be relative for a give directory. This is
   * used when a block of CSS code is going to be added on a extended SFC.
   * @param {String} css       The code to update.
   * @param {String} directory The relative path to the directory in which the extended SFC is
   *                           located.
   * @return {String}
   * @access protected
   * @ignore
   */
  _updateCSSPaths(css, directory) {
    return this._updateCodePaths(css, this._expressions.cssUrl, directory);
  }
  /**
   * Utility method that updates paths on a given code to make them relative to a new directory.
   * This is used to update the contents of an SFC before they are added to one that extends it.
   * @param {String} code       The code to update.
   * @param {RegExp} expression The expression to extract the relative paths.
   * @param {String} directory  The relative path to the directory in which the extended SFC is
   *                            located.
   * @return {String}
   * @access protected
   * @ignore
   */
  _updateCodePaths(code, expression, directory) {
    const items = [];
    let match = expression.exec(code);
    while (match) {
      const [statement, itemPath, alternativeItemPath] = match;
      items.push({
        statement,
        itemPath: itemPath || alternativeItemPath,
      });

      match = expression.exec(code);
    }

    const newCode = items.reduce(
      (currentCode, item) =&gt; {
        const newItemPath = path.join(directory, item.itemPath).replace(/^(\w)/, &apos;./$1&apos;);
        const newStatement = item.statement.replace(item.itemPath, newItemPath);
        return currentCode.replace(item.statement, newStatement);
      },
      code
    );

    return newCode;
  }
  /**
   * A utility method that parses the value of an `extend` HTML attribute the class uses to
   * determine the position of the base code in relation with the extended one:
   * - `undefined` or `&apos;false&apos;`: `null` - the code won&apos;t be merged.
   * - no value, `&apos;true&apos;` or `&apos;after&apos;`: first the base code and then the extended one.
   * - `&apos;before&apos;`: first the extended code and then the base one.
   * @param {String} [value] The value of the `extend` HTML attribute.
   * @return {?String} If the attribute is not defined or if it&apos;s value is `&apos;false&apos;`, it will
   *                   return `null`, indicating that the code shouldn&apos;t be merged.
   * @access protected
   * @ignore
   */
  _getMergePosition(value) {
    const defaultValue = &apos;after&apos;;
    let result;
    const valueType = typeof value;
    if (valueType === &apos;undefined&apos; || !value) {
      result = null;
    } else if (valueType === &apos;string&apos;) {
      result = value.match(/(?:before|after)/i) ? value.toLowerCase() : defaultValue;
    } else {
      result = defaultValue;
    }

    return result;
  }
  /**
   * Utility method to remove empty lines from the beginning and end of a block of code. This
   * method exists because is common for a block to end up like this when merging its contents.
   * @param {String} text The text to clean.
   * @return {String}
   * @access protected
   * @ignore
   */
  _cleanTextBlock(text) {
    const newText = text
    .replace(/^\n/, &apos;&apos;)
    .replace(/\n$/, &apos;&apos;);

    return newText.trim() ? newText : &apos;&apos;;
  }
  /**
   * Removes the {@link Extender#_privateAttributes} from a dictionary of attributes.
   * @param {Object} attributes The dictionary of attributes to clean.
   * @return {Object} A new dictionary without the private attributes
   * @access protected
   * @ignore
   */
  _cleanAttributes(attributes) {
    const result = Object.assign({}, attributes);
    this._privateAttributes.forEach((name) =&gt; {
      delete result[name];
    });

    return result;
  }
}
/**
 * The service provider that once registered on {@link SvelteExtend} will save the an instance of
 * {@link JSMerger} as the `jsMerger` service.
 * @type {Provider}
 */
const extender = provider((app) =&gt; {
  app.set(&apos;extender&apos;, () =&gt; new Extender(
    app.get(&apos;jsMerger&apos;),
    app.get(&apos;sfcData&apos;)
  ));
});

module.exports = {
  Extender,
  extender,
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
